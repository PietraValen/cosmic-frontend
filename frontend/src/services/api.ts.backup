// Service para comunica√ß√£o com a API backend
import {
  buildApiUrl,
  buildAuthHeaders,
  setAuthToken,
  removeAuthToken,
} from "@/config";

// Tipos para as respostas da API
export interface ApiResponse<T = unknown> {
  success: boolean;
  message: string;
  data?: T;
  token?: string;
  user?: User;
}

export interface User {
  id: string;
  name: string;
  email: string;
  role: string;
}

export interface LoginData {
  email: string;
  password: string;
}

export interface RegisterData {
  name: string;
  email: string;
  password: string;
  password_confirmation?: string; // Laravel espera este campo
}

export interface Classification {
  id: string;
  glitchId: string;
  userId: string;
  classification: string;
  confidence: number;
  notes?: string;
  timestamp: string;
}

export interface Spectrogram {
  id: string;
  glitchId?: string;
  url: string;
  filename: string;
  uploadedAt: string;
  metadata?: Record<string, unknown>;
}

export interface Detector {
  id: string;
  name: string;
  code: string;
  latitude: number;
  longitude: number;
  location: string;
  country: string;
  arm_length_km: number;
  status: 'active' | 'maintenance' | 'offline';
  operational_since: string;
  description: string;
  color: string;
}

export interface GlitchType {
  id: string;
  name: string;
  description: string;
}

export interface GlitchData {
  id: string;
  detector_id: string;
  glitch_type_id: string;
  timestamp: string;
  peak_frequency: number;
  snr: number;
  duration: number;
  confidence: number;
  classification_method: 'ai' | 'human';
  spectrogram_url?: string;
  notes?: string;
  validated: boolean;
  validated_by?: string;
  validated_at?: string;
  detector?: Detector;
  glitch_type?: GlitchType;
}

export interface GravitationalEvent {
  id: string;
  name: string;
  event_date: string;
  latitude: number;
  longitude: number;
  event_type: 'BBH' | 'BNS' | 'NSBH' | 'Unknown';
  mass_1: number;
  mass_2: number;
  distance_mpc: number;
  false_alarm_rate: number;
  description: string;
  significance: 'Alta' | 'Muito Alta' | 'Baixa';
  detectors: string[];
  color: string;
}

export interface Observatory {
  id: string;
  name: string;
  description: string;
}

export interface ProjectStatistic {
  id: string;
  name: string;
  description: string;
  value?: number;
  unit?: string;
}

export interface ScientificDiscovery {
  id: string;
  name: string;
  description: string;
  discovery_date?: string;
  importance?: 'High' | 'Medium' | 'Low';
}

export interface UploadMetadata {
  description?: string;
  tags?: string[];
  detector?: string;
  timestamp?: string;
}

// Classe principal do service
class ApiService {
  private async makeRequest<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = buildApiUrl(endpoint);

    const defaultOptions: RequestInit = {
      headers: buildAuthHeaders(),
      ...options,
    };

    try {
      console.log("üîó API Request:", { url, options: defaultOptions });

      const response = await fetch(url, defaultOptions);

      console.log(
        "üì° API Response Status:",
        response.status,
        response.statusText
      );

      let data;
      try {
        data = await response.json();
      } catch (jsonError) {
        console.error("‚ùå JSON Parse Error:", jsonError);
        throw new Error(
          `Erro ao parsear resposta JSON: ${response.status} ${response.statusText}`
        );
      }

      console.log("üì¶ API Response Data:", data);

      if (!response.ok) {
        throw new Error(
          data.message || `Erro HTTP ${response.status}: ${response.statusText}`
        );
      }

      return {
        success: true,
        message: data.message || "Sucesso",
        data: data.data || data,
        token: data.token,
        user: data.user,
      };
    } catch (error) {
      console.error("‚ùå Erro na API:", error);

      // Se for erro de rede, dar mais detalhes
      if (error instanceof TypeError && error.message.includes("fetch")) {
        return {
          success: false,
          message: `Erro de conex√£o: N√£o foi poss√≠vel conectar com ${url}. Verifique se o Laravel est√° rodando.`,
        };
      }

      return {
        success: false,
        message: error instanceof Error ? error.message : "Erro desconhecido",
      };
    }
  }

  // ========== M√âTODOS DE AUTENTICA√á√ÉO ==========

  async login(credentials: LoginData): Promise<ApiResponse<User>> {
    console.log("üîÑ Iniciando login com:", credentials.email);

    const response = await this.makeRequest<{
      access_token?: string;
      token_type?: string;
      expires_in?: number;
    }>("/login", {
      method: "POST",
      body: JSON.stringify(credentials),
    });

    console.log("üì° Resposta do login:", response);

    // Laravel Sanctum retorna formato: { access_token, token_type, expires_in }
    if (response.success && response.data) {
      const laravelData = response.data;

      // Se tem access_token, √© resposta do Laravel
      if (laravelData.access_token) {
        const token = laravelData.access_token;
        setAuthToken(token);

        // Buscar dados do usu√°rio com o token
        try {
          const userResponse = await fetch(buildApiUrl("/me"), {
            headers: {
              Authorization: `Bearer ${token}`,
              Accept: "application/json",
              "Content-Type": "application/json",
            },
          });

          if (userResponse.ok) {
            const userData = await userResponse.json();
            if (typeof window !== "undefined") {
              localStorage.setItem(
                "cosmic-user-data",
                JSON.stringify(userData)
              );
            }

            return {
              success: true,
              message: "Login realizado com sucesso!",
              user: userData,
              token: token,
            };
          }
        } catch (userError) {
          console.error("Erro ao buscar dados do usu√°rio:", userError);
        }

        // Fallback: usar dados m√≠nimos
        const fallbackUser = {
          id: "1",
          name: "Usu√°rio",
          email: credentials.email,
          role: "user",
        };

        if (typeof window !== "undefined") {
          localStorage.setItem(
            "cosmic-user-data",
            JSON.stringify(fallbackUser)
          );
        }

        return {
          success: true,
          message: "Login realizado com sucesso!",
          user: fallbackUser,
          token: token,
        };
      }
    }

    return {
      success: false,
      message: response.message || "Login falhou",
    };
  }

  async logout(): Promise<ApiResponse> {
    const response = await this.makeRequest("/logout", {
      method: "POST",
    });

    // Remove o token independentemente da resposta da API
    removeAuthToken();

    if (typeof window !== "undefined") {
      localStorage.removeItem("cosmic-user-data");
    }

    return response;
  }

  async getUserProfile(): Promise<ApiResponse<User>> {
    return this.makeRequest<User>("/me");
  }

  async refreshToken(): Promise<ApiResponse<{ access_token: string }>> {
    return this.makeRequest<{ access_token: string }>("/refresh", {
      method: "POST",
    });
  }

  // ========== M√âTODOS DE DETECTORES ==========

  async getDetectors(): Promise<ApiResponse<Detector[]>> {
    return this.makeRequest<Detector[]>("/detectors");
  }

  async getDetector(id: string): Promise<ApiResponse<Detector>> {
    return this.makeRequest<Detector>(`/detectors/${id}`);
  }

  async createDetector(detector: Omit<Detector, 'id'>): Promise<ApiResponse<Detector>> {
    return this.makeRequest<Detector>("/detectors", {
      method: "POST",
      body: JSON.stringify(detector),
    });
  }

  async updateDetector(id: string, detector: Partial<Detector>): Promise<ApiResponse<Detector>> {
    return this.makeRequest<Detector>(`/detectors/${id}`, {
      method: "PUT",
      body: JSON.stringify(detector),
    });
  }

  async deleteDetector(id: string): Promise<ApiResponse> {
    return this.makeRequest(`/detectors/${id}`, {
      method: "DELETE",
    });
  }

  // ========== M√âTODOS DE GLITCHES ==========

  async getGlitches(params?: {
    detector_id?: string;
    glitch_type_id?: string;
    limit?: number;
    offset?: number;
    start_date?: string;
    end_date?: string;
  }): Promise<ApiResponse<GlitchData[]>> {
    const queryParams = new URLSearchParams();

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          queryParams.append(key, value.toString());
        }
      });
    }

    const endpoint = `/glitches${
      queryParams.toString() ? "?" + queryParams.toString() : ""
    }`;
    return this.makeRequest<GlitchData[]>(endpoint);
  }

  async getGlitch(id: string): Promise<ApiResponse<GlitchData>> {
    return this.makeRequest<GlitchData>(`/glitches/${id}`);
  }

  async createGlitch(glitch: Omit<GlitchData, 'id'>): Promise<ApiResponse<GlitchData>> {
    return this.makeRequest<GlitchData>("/glitches", {
      method: "POST",
      body: JSON.stringify(glitch),
    });
  }

  async updateGlitch(id: string, glitch: Partial<GlitchData>): Promise<ApiResponse<GlitchData>> {
    return this.makeRequest<GlitchData>(`/glitches/${id}`, {
      method: "PUT",
      body: JSON.stringify(glitch),
    });
  }

  async deleteGlitch(id: string): Promise<ApiResponse> {
    return this.makeRequest(`/glitches/${id}`, {
      method: "DELETE",
    });
  }

  // ========== M√âTODOS DE TIPOS DE GLITCHES ==========

  async getGlitchTypes(): Promise<ApiResponse<GlitchType[]>> {
    return this.makeRequest<GlitchType[]>("/glitch-types");
  }

  async getGlitchType(id: string): Promise<ApiResponse<GlitchType>> {
    return this.makeRequest<GlitchType>(`/glitch-types/${id}`);
  }

  async createGlitchType(glitchType: Omit<GlitchType, 'id'>): Promise<ApiResponse<GlitchType>> {
    return this.makeRequest<GlitchType>("/glitch-types", {
      method: "POST",
      body: JSON.stringify(glitchType),
    });
  }

  async updateGlitchType(id: string, glitchType: Partial<GlitchType>): Promise<ApiResponse<GlitchType>> {
    return this.makeRequest<GlitchType>(`/glitch-types/${id}`, {
      method: "PUT",
      body: JSON.stringify(glitchType),
    });
  }

  async deleteGlitchType(id: string): Promise<ApiResponse> {
    return this.makeRequest(`/glitch-types/${id}`, {
      method: "DELETE",
    });
  }

  // ========== M√âTODOS DE EVENTOS GRAVITACIONAIS ==========

  async getGravitationalEvents(): Promise<ApiResponse<GravitationalEvent[]>> {
    return this.makeRequest<GravitationalEvent[]>("/events");
  }

  async getGravitationalEvent(id: string): Promise<ApiResponse<GravitationalEvent>> {
    return this.makeRequest<GravitationalEvent>(`/events/${id}`);
  }

  async createGravitationalEvent(event: Omit<GravitationalEvent, 'id'>): Promise<ApiResponse<GravitationalEvent>> {
    return this.makeRequest<GravitationalEvent>("/events", {
      method: "POST",
      body: JSON.stringify(event),
    });
  }

  async updateGravitationalEvent(id: string, event: Partial<GravitationalEvent>): Promise<ApiResponse<GravitationalEvent>> {
    return this.makeRequest<GravitationalEvent>(`/events/${id}`, {
      method: "PUT",
      body: JSON.stringify(event),
    });
  }

  async deleteGravitationalEvent(id: string): Promise<ApiResponse> {
    return this.makeRequest(`/events/${id}`, {
      method: "DELETE",
    });
  }

  // ========== M√âTODOS DE OBSERVAT√ìRIOS ==========

  async getObservatories(): Promise<ApiResponse<Observatory[]>> {
    return this.makeRequest<Observatory[]>("/observatories");
  }

  async getObservatory(id: string): Promise<ApiResponse<Observatory>> {
    return this.makeRequest<Observatory>(`/observatories/${id}`);
  }

  async createObservatory(observatory: Omit<Observatory, 'id'>): Promise<ApiResponse<Observatory>> {
    return this.makeRequest<Observatory>("/observatories", {
      method: "POST",
      body: JSON.stringify(observatory),
    });
  }

  async updateObservatory(id: string, observatory: Partial<Observatory>): Promise<ApiResponse<Observatory>> {
    return this.makeRequest<Observatory>(`/observatories/${id}`, {
      method: "PUT",
      body: JSON.stringify(observatory),
    });
  }

  async deleteObservatory(id: string): Promise<ApiResponse> {
    return this.makeRequest(`/observatories/${id}`, {
      method: "DELETE",
    });
  }

  // ========== M√âTODOS DE ESTAT√çSTICAS DE PROJETOS ==========

  async getProjectStatistics(): Promise<ApiResponse<ProjectStatistic[]>> {
    return this.makeRequest<ProjectStatistic[]>("/project-statistics");
  }

  async getProjectStatistic(id: string): Promise<ApiResponse<ProjectStatistic>> {
    return this.makeRequest<ProjectStatistic>(`/project-statistics/${id}`);
  }

  async createProjectStatistic(statistic: Omit<ProjectStatistic, 'id'>): Promise<ApiResponse<ProjectStatistic>> {
    return this.makeRequest<ProjectStatistic>("/project-statistics", {
      method: "POST",
      body: JSON.stringify(statistic),
    });
  }

  async updateProjectStatistic(id: string, statistic: Partial<ProjectStatistic>): Promise<ApiResponse<ProjectStatistic>> {
    return this.makeRequest<ProjectStatistic>(`/project-statistics/${id}`, {
      method: "PUT",
      body: JSON.stringify(statistic),
    });
  }

  async deleteProjectStatistic(id: string): Promise<ApiResponse> {
    return this.makeRequest(`/project-statistics/${id}`, {
      method: "DELETE",
    });
  }

  // ========== M√âTODOS DE DESCOBERTAS CIENT√çFICAS ==========

  async getScientificDiscoveries(): Promise<ApiResponse<ScientificDiscovery[]>> {
    return this.makeRequest<ScientificDiscovery[]>("/scientific-discoveries");
  }

  async getScientificDiscovery(id: string): Promise<ApiResponse<ScientificDiscovery>> {
    return this.makeRequest<ScientificDiscovery>(`/scientific-discoveries/${id}`);
  }

  async createScientificDiscovery(discovery: Omit<ScientificDiscovery, 'id'>): Promise<ApiResponse<ScientificDiscovery>> {
    return this.makeRequest<ScientificDiscovery>("/scientific-discoveries", {
      method: "POST",
      body: JSON.stringify(discovery),
    });
  }

  async updateScientificDiscovery(id: string, discovery: Partial<ScientificDiscovery>): Promise<ApiResponse<ScientificDiscovery>> {
    return this.makeRequest<ScientificDiscovery>(`/scientific-discoveries/${id}`, {
      method: "PUT",
      body: JSON.stringify(discovery),
    });
  }

  async deleteScientificDiscovery(id: string): Promise<ApiResponse> {
    return this.makeRequest(`/scientific-discoveries/${id}`, {
      method: "DELETE",
    });
  }

  async register(userData: RegisterData): Promise<ApiResponse<User>> {
    console.log("üîÑ Iniciando registro para:", userData.email);

    // Adicionar password_confirmation para Laravel
    const registrationData = {
      ...userData,
      password_confirmation: userData.password,
    };

    const response = await this.makeRequest<{
      access_token?: string;
      token_type?: string;
      expires_in?: number;
    }>("/api/register", {
      method: "POST",
      body: JSON.stringify(registrationData),
    });

    console.log("üì° Resposta do registro:", response);

    // Laravel Sanctum pode retornar formato: { access_token, token_type, expires_in }
    if (response.success && response.data) {
      const laravelData = response.data;

      // Se tem access_token, √© resposta do Laravel
      if (laravelData.access_token) {
        const token = laravelData.access_token;
        setAuthToken(token);

        // Buscar dados do usu√°rio com o token
        try {
          const userResponse = await fetch(buildApiUrl("/api/user"), {
            headers: {
              Authorization: `Bearer ${token}`,
              Accept: "application/json",
              "Content-Type": "application/json",
            },
          });

          if (userResponse.ok) {
            const userData = await userResponse.json();
            if (typeof window !== "undefined") {
              localStorage.setItem(
                "cosmic-user-data",
                JSON.stringify(userData)
              );
            }

            return {
              success: true,
              message: "Conta criada com sucesso!",
              user: userData,
              token: token,
            };
          }
        } catch (userError) {
          console.error("Erro ao buscar dados do usu√°rio:", userError);
        }

        // Fallback: usar dados b√°sicos
        const fallbackUser = {
          id: "1",
          name: userData.name,
          email: userData.email,
          role: "user",
        };

        if (typeof window !== "undefined") {
          localStorage.setItem(
            "cosmic-user-data",
            JSON.stringify(fallbackUser)
          );
        }

        return {
          success: true,
          message: "Conta criada com sucesso!",
          user: fallbackUser,
          token: token,
        };
      }
    }

    return {
      success: false,
      message: response.message || "Registro falhou",
    };
  }

  // ========== M√âTODOS DE DADOS CIENT√çFICOS ==========

  async getGlitches(params?: {
    type?: string;
    limit?: number;
    offset?: number;
  }): Promise<ApiResponse<GlitchData[]>> {
    const queryParams = new URLSearchParams();

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          queryParams.append(key, value.toString());
        }
      });
    }

    const endpoint = `/api/glitches${
      queryParams.toString() ? "?" + queryParams.toString() : ""
    }`;
    return this.makeRequest<GlitchData[]>(endpoint);
  }

  async getClassifications(): Promise<ApiResponse<Classification[]>> {
    return this.makeRequest<Classification[]>("/api/classifications");
  }

  async getSpectrograms(
    glitchId?: string
  ): Promise<ApiResponse<Spectrogram[]>> {
    const endpoint = glitchId
      ? `/api/spectrograms/${glitchId}`
      : "/api/spectrograms";
    return this.makeRequest<Spectrogram[]>(endpoint);
  }

  async getDetectors(): Promise<ApiResponse<Detector[]>> {
    return this.makeRequest<Detector[]>("/api/detectors");
  }

  async submitClassification(data: {
    glitchId: string;
    classification: string;
    confidence: number;
    notes?: string;
  }): Promise<ApiResponse> {
    return this.makeRequest("/api/classifications", {
      method: "POST",
      body: JSON.stringify(data),
    });
  }

  // ========== M√âTODOS DE UPLOAD ==========

  async uploadSpectrogram(
    file: File,
    metadata?: UploadMetadata
  ): Promise<ApiResponse> {
    const formData = new FormData();
    formData.append("file", file);

    if (metadata) {
      formData.append("metadata", JSON.stringify(metadata));
    }

    const url = buildApiUrl("/api/spectrograms/upload");

    try {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          // N√£o inclua Content-Type para FormData - o browser define automaticamente
          Authorization: `Bearer ${
            localStorage.getItem("cosmic-auth-token") || ""
          }`,
        },
        body: formData,
      });

      const data = await response.json();

      return {
        success: response.ok,
        message:
          data.message ||
          (response.ok ? "Upload realizado com sucesso" : "Erro no upload"),
        data: data.data || data,
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : "Erro no upload",
      };
    }
  }

  // ========== M√âTODOS UTILIT√ÅRIOS ==========

  // M√©todo para buscar estat√≠sticas do dashboard
  async getDashboardStats(): Promise<ApiResponse<{
    totalDetectors: number;
    totalGlitches: number;
    totalEvents: number;
    totalObservatories: number;
    recentDiscoveries: number;
    systemHealth: 'healthy' | 'warning' | 'critical';
  }>> {
    return this.makeRequest("/dashboard/stats");
  }

  // M√©todo para buscar dados de an√°lise em tempo real
  async getRealtimeAnalysis(): Promise<ApiResponse<{
    currentDetections: number;
    signalStrength: number;
    noiseLevel: number;
    status: string;
    lastUpdate: string;
  }>> {
    return this.makeRequest("/analysis/realtime");
  }

  // M√©todo para buscar hist√≥rico de atividades do usu√°rio
  async getUserActivity(params?: {
    limit?: number;
    offset?: number;
    start_date?: string;
    end_date?: string;
  }): Promise<ApiResponse<Array<{
    id: string;
    action: string;
    description: string;
    timestamp: string;
    category: string;
  }>>> {
    const queryParams = new URLSearchParams();

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          queryParams.append(key, value.toString());
        }
      });
    }

    const endpoint = `/user/activity${
      queryParams.toString() ? "?" + queryParams.toString() : ""
    }`;
    return this.makeRequest(endpoint);
  }

  // M√©todo para buscar relat√≥rios dispon√≠veis
  async getReports(): Promise<ApiResponse<Array<{
    id: string;
    name: string;
    description: string;
    type: string;
    createdAt: string;
    status: 'ready' | 'processing' | 'error';
  }>>> {
    return this.makeRequest("/reports");
  }

  // M√©todo para gerar novo relat√≥rio
  async generateReport(config: {
    type: string;
    parameters: Record<string, string | number | boolean>;
    format: 'pdf' | 'csv' | 'json';
  }): Promise<ApiResponse<{ reportId: string }>> {
    return this.makeRequest("/reports/generate", {
      method: "POST",
      body: JSON.stringify(config),
    });
  }

  // M√©todo para buscar espectrogramas
  async getSpectrograms(params?: {
    detector_id?: string;
    limit?: number;
    offset?: number;
    start_date?: string;
    end_date?: string;
  }): Promise<ApiResponse<Array<{
    id: string;
    detectorId: string;
    timestamp: string;
    frequency: number;
    amplitude: number;
    imageUrl?: string;
    metadata: Record<string, string | number>;
  }>>> {
    const queryParams = new URLSearchParams();

    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          queryParams.append(key, value.toString());
        }
      });
    }

    const endpoint = `/spectrograms${
      queryParams.toString() ? "?" + queryParams.toString() : ""
    }`;
    return this.makeRequest(endpoint);
  }

  // M√©todo para testar conex√£o com a API
  async testConnection(): Promise<ApiResponse<{ status: string; timestamp: string }>> {
    return this.makeRequest("/health");
  }

  // ========== M√âTODOS DE STATUS ==========

  async checkHealth(): Promise<ApiResponse> {
    return this.makeRequest("/health");
  }

  async getStats(): Promise<
    ApiResponse<{
      totalGlitches: number;
      totalClassifications: number;
      totalUsers: number;
      accuracy: number;
    }>
  > {
    return this.makeRequest("/stats");
  }
}

// Inst√¢ncia singleton do service
const apiService = new ApiService();

// Exporta√ß√µes principais
export default apiService;
export const api = apiService;

// Fun√ß√µes utilit√°rias exportadas
export { setAuthToken, removeAuthToken, getAuthToken };

// Tipos exportados para uso em componentes
export type {
  User,
  Detector,
  GlitchData,
  GlitchType,
  GravitationalEvent,
  Observatory,
  ProjectStatistic,
  ScientificDiscovery,
  LoginData,
  RegisterData,
  ApiResponse,
};
